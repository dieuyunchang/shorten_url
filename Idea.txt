Hello interviewer! I write this file to explain the idea and also share my opinion to able adapting real life situations

1/ The idea of encode and decode
  a/ current
    - Because the requirement is required `URL can be encoded into a short URL and that the short URL can be decoded back into the original URL`, so I decided to use the the record id 
    to encode and decode back id to get the original_url.
    - The Encode idea is try to get the remainder of division a by alphabet string length, with alphabet is the character from 0-9,a-z,A-Z, uniq character.
    - The result of Encode service will be the short_code with length from 1-6
    - Flow
      - User submit the long url from UI
      - `Api::ShortenController` call the service `CreateShortenLink`
      - The service `CreateShortenLink` will check the `ShortenedUrl` table to find the existing one by sanitize the original url
        - if have, Encode the found record id and return the shortened link
        - if dont have, then create the `ShortenedUrl` record and encode the id and return the shortened link
      - `Api::ShortenController` respond the shortened link
      - Guest user input this shortted link into browser
      - LinkController will call the finder `OriginalUrlFinder` with short_code
      - The finder will decode the short_code to get the id and find `ShortenedUrl` to get the original_url
      - LinkController redirect to original_url if found, or redirect to 404 page

    - The limitation of this way are:
      - the short_code can be more then 7 character if the id more than ~ 5 mil
      - Each character of short_code can't be repeat
    - The good one:
      - because the character will be generated by increment id, so no conflict on generate the short_code
      - we dont need to store the short_code
  b/ real life
    - Can create the short_code by the original_url with 
      - Digest::SHA256.hexdigest("http://google.com")[0..5]
      - SecureRandom.hex(10)[0..5]
      - generate again if this short_code exist in `ShortenedUrl` table
    - Store the short_code into the `ShortenedUrl` attribute, then we can find the original_url by this short_code instead

2/ The idea of rate limit
  a/ current
    - because the requirement have a big confusing about the service will serve continuously for a few numbers of users (max 2 - 5 requests per second), I don't know it is the should stop and not allow
    user to call api or should allow them, but should be in queue
    - So I implement with block the request when server full, response with status 503
  b/ Incase requirement is allow user still able to send the request
    - The idea can be:
    - Add sidekiq gem to use the background job
    - Each request will be push into the queue
    - For limit rate, we can set the waiting time for the job, the counting rate can store in redis:
      - request come -> create the background job
      - set the counter plus 1 into
      - when the job finish, reduce the counter
  c/ real life
    My opinion is to block the request and let user retry again
    - The good:
      - To avoid the conflict
      - Avoid DDOS

    - the worst case


3/ life of record
  - For the long term, the data will be fat and almost is used after a wait. So we should have the expired date for each shortened_url and have the scheduler to clearn up it after 7days, 1 months,...
